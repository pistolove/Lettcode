IO包中的2种设计模式 装饰者模式和适配器
InputStream--FilterInputStream--BufferedInputSteam
InputSteam--FileInputStream
          --byteArrayInputStream
          --InputStreamReader
          

集合类 iterator -- collection--set---list          map---abstractmap

set--hashset 实质是一个hashMap LinkedHashSet 实质是一个linkedHashMap 其key是一个链表
list--arraylist 实质是一个数组 是有序的 LinkedList 双向链表  vector 线程安全的
map--hashMap 线程不安全的 LinkedHashMap继承了hashmap 其中的entry是有前驱和后继的

hashtable 线程安全 多线程情况下回导致效率比较低

concurrentHashMap 锁机制----- 允许多个读写操作并发执行
多线程条件下使用多线程会导致hashMap的put操作死循环，可以使用hashTable但是会出现效率低下，
使用分段锁技术，将数据分成一段一段的存储，然后每一段加上一把锁，当其中一个线程占用锁访问其中的一个段数据的时候，
其它段的数据也是可以访问的，实现真正的并发。

concurrentHashMap----多个segMent---每个segMent中包含若干EntrySet
需要进过3次hash来确定具体的值
jdk 1.8中进行了修改。

put方法中加了锁机制。
锁分离机制：使用Segment extends ReentrantLock


HashMap的put方法
首先根据key去hash一次找到该key在数组中的位置，然后根据hash后的值在数组中寻找，如果找到的节点为空就说明没有节点，直接将该节点放入即可，
如果找到节点，说明找到了一个链表，就判断链表第一个节点是否和新增的节点hash值和equals都相等，如果相等则直接覆盖，否则，如果节点是一个TreeNode类型，
则直接放入红黑树中；否则，则默认是链表存储，在链表中头往后寻找，如果其中发现节点的next节点为空，则将next节点设为当前节点，
如果节点数量大于阈值8，则将链表转换为红黑树，如果发现遍历的节点和当前节点完全一样，则直接终止寻找。
更新hash值和key值相同的旧的值。
最后还需判断是否需要resize，容量增加一倍，需要重新进行hash。



异常机制  throwable-- error 、exception
error错误
exception包括runtimeException和受检查的异常

IOException FileNotFoundException

********
类加载机制：
怎么加载类？
哪些类需要加载？
加载顺序是什么样的？
1、寻找jre目录，寻找jvm.dll，并初始化JVM；
2、产生一个Bootstrap Loader（启动类加载器）；
3、Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。
4、Bootstrap Loader自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。
5、最后由AppClass Loader加载HelloWorld类。

bootstrapLoader-->appLoader-->extLoader


JVM内存管理 怎么管理？
堆:公共区域 存储对象
栈：线程私有
本地方法栈：native方法的调用
程序计数器：线程私有，线程切换回到正确的位置
方法区：类加载信息 常量 静态变量 编译器编译后的代码

JVM垃圾回收机制 为什么分代？不同代回收机制、策略不通？ 算法也不同？
哪些需要回收？什么时候回收？怎么回收？
对象没有引用 未捕获的异常 执行完毕 System.exit() 意外终止

判断对象已经死亡？引用计数但是可能会产生相互引用、是否可达分析
回收算法：
标记清除算法：标记存活对象，清除未标记的对象
复制算法：存活对象放入一块区域，清除其余区域
标记整理：标记存活对象并进行整理，然后清除没有标记的对象，减少碎片空间
分代收集：年轻代、年老代
标记清除

minor gc 年轻代 速度快 执行频率高
full gc 年老代 速度慢 耗时 

串行垃圾回收：单线程、清理时会停止所有的工作 复制
并行垃圾回收：多线程 标记整理 标记清除 
对于年轻代来说，分为Eden和两个Survivor区域，其中比例一般为8：1：1
对象优先会放在Eden中，如果Eden满了，再来的对象就会放入其中的一个survivor中，
如果这一个满了的话 就会进行一次minior gc 将存活的对象放入另外一个 survivor中
然后清除Eden和其中的一个survivor 另一个survivor中对象的年龄加1岁 默认到达
15岁的时候就会移动到年老区
对于大的对象可能直接就进入到老年区

年轻代空间不足就会触发full gc ，年老代空间不足就会抛出异常
Permanet Generation空间满
Minor GC 后晋升到旧生代的平均大小大于旧生代的剩余空间

将不用的对象设置为null
使用对象池技术
使用JVM参数进行调优

年轻代 年老代 持久代
年轻代朝生夕灭




设计模式：观察者、代理、策略、装饰者、适配器、门面、抽象工厂、工厂、单例
观察者是一个一对多的关系，通知方发生改变时会通知收听方。
代理模式目标对象要做的事让代理对象来做，需要实现相同的接口。
策略模式是有多种不同的算法，依据不同的策略跳转不同的方法中去，比如会员的服务，分为一般用户、普通会员、高级会员等
装饰者模式是接接受一个相同的高层接口，动态扩展类的功能。
适配器模式使得不能适配的对象可以变得通用，将一个接口转换为另一个期望的接口，比如FileInputStream接收一个String类型的路径返回.
门面模式：构建客户端可多个子系统之间的桥接关系，提供一个接口来访问子系统中的一群接口

创建者模式：StringBuilder
原型模式：使用自己的实例来创建另一个实例 clone方法
享元模式：有效地存储大量小对象 Integer.valueOf()
迭代器模式：对象遍历 Iterator
Template(模板):定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中 InputStream中的skip() read()



******
concurrent中代码学习 为什么使用线程池？如何使用？ 减少线程创建销毁  redis单线程？
线程池使得线程可以重复使用，创建线程和销毁线程是很消耗资源的。
Executor -->ExecutorService--->AbstractExecutorService-->ThreadPoolExecutor
Executor:execute()
ExecutorService:submit()
AbstractExecutorService:提供默认实现
ThreadPoolExecutor：具体的线程池
主要包含：
BlockingQueue<Runnable> workQueue 工作等待队列
HashSet<Worker> workers 工作空间 装了待执行的线程 最后运行的是这里面的线程
Worker ：AQS需要看下**************************

******************************
ThreadPoolExecutor线程池详解：

AtomicInteger是干什么用的，搞并发情况下保证多线程修改数值的正确性。具有自增自减功能。
并不是因为volatile，是因为unsafe

CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 乐观锁 技术，
当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，
而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。
当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS无锁算法的C实现如下：

int compare_and_swap (int* reg, int oldval, int newval) 
{
  ATOMIC();
  int old_reg_val = *reg;
  if (old_reg_val == oldval) 
     *reg = newval;
  END_ATOMIC();
  return old_reg_val;
}

线程的演变：
单线程-->多线程-->线程池-->工作队列
单线程只能够顺序执行任务，多线程不受限制创建可能导致服务器资源枯竭，线程池可是创建少量的线程来不停处理请求，
请求处理完成后线程被回收到线程池中，但是当线程池中的线程都在工作时，新来一个线程怎么办呢。这里就需要用到工作队列，
工作队列中保存排队的任务，如果队列满了，新来的任务则需要进行策略上的判断，抛异常或者直接舍弃。

*********************************
guava future学习  异步非阻塞调用

future-->ListenableFuture-->AbstractFuture

Future普通的Future,异步计算结果

ListenableFuture 增加回调功能

AbstractFuture 抽象的Future

  public void addListener(Runnable listener, Executor exec) {
    executionList.add(listener, exec);
  }
  对指定任务增加监听

    private final Sync<V> sync = new Sync<V>();

    // The execution list to hold our executors.
     private final ExecutionList executionList = new ExecutionList();
ExecutionList
      private RunnableExecutorPair runnables;
RunnableExecutorPair
      final Runnable runnable;
     final Executor executor;
实质是一个链表，保存了当前执行的任务和线程池。执行时候需要将链表翻转，然后一个一个地执行。

Executor -->ExecutorService--->AbstractExecutorService-->ThreadPoolExecutor

abstract class AbstractListeningExecutorService extends AbstractExecutorService implements ListeningExecutorService 

Executor-->ExecutorService-->ListeningExecutorService-->AbstractListeningExecutorService-->ListeningDecorator

  public static ListeningExecutorService listeningDecorator(
      ExecutorService delegate) {
    return new ListeningDecorator(delegate);
  }


1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：
    a. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
    b. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。
    c. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；
    d. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。
3、当一个线程完成任务时，它会从队列中取下一个任务来执行。
4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。
       这个过程说明，并不是先加入任务就一定会先执行。假设队列大小为 4，corePoolSize为2，maximumPoolSize为6，那么当加入15个任务时，执行的顺序类似这样：首先执行任务 1、2，然后任务3~6被放入队列。
       这时候队列满了，任务7、8、9、10 会被马上执行，而任务 11~15 则会抛出异常。最终顺序是：1、2、7、8、9、10、3、4、5、6。
       当然这个过程是针对指定大小的ArrayBlockingQueue<Runnable>来说，如果是LinkedBlockingQueue<Runnable>，因为该队列无大小限制，所以不存在上述问题。


**************************************


*************************************
asyncRestTemplate异步批量调用小框架
自动化API文档结构及思考 用到的技术：IO、模式

********
数据结构和算法  七大排序算法、KMP字符串算法、二分查找、栈、队列、树、二叉树、最短路径、动态规划、桶排序
冒泡排序：
希尔排序：
插入排序：
快速排序：
堆排序：
归并排序：



ObjectMapper反序列化Deserializer 自定义反序列化


********
NIO学习 为什么使用NIO



Spring MVC中aop学习


Spring-mvc包的学习


linux shell 学习


********
protobuf 了解学习


*********
http协议：
    http请求由三部分组成，分别是：请求行、消息报头、请求正文
    
请求方法（所有方法全为大写）有多种，各个方法的解释如下：
GET     请求获取Request-URI所标识的资源
POST    在Request-URI所标识的资源后附加新的数据
HEAD    请求获取由Request-URI所标识的资源的响应消息报头
PUT     请求服务器存储一个资源，并用Request-URI作为其标识
DELETE  请求服务器删除Request-URI所标识的资源
TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断
CONNECT 保留将来使用
OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求

在接收和解释请求消息后，服务器返回一个HTTP响应消息。

HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文
1、状态行格式如下：
HTTP-Version Status-Code Reason-Phrase CRLF
其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。
状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见状态代码、状态描述、说明：
200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

21/tcp FTP 文件传输协议 
22/tcp SSH 安全登录、文件传送(SCP)和端口重定向 
23/tcp Telnet 不安全的文本传送 
25/tcp SMTP Simple Mail Transfer Protocol (E-mail) 
69/udp TFTP Trivial File Transfer Protocol 
79/tcp finger Finger 
80/tcp HTTP 超文本传送协议 (WWW) 
88/tcp Kerberos Authenticating agent 
110/tcp POP3 Post Office Protocol (E-mail) 
113/tcp ident old identification server system 
119/tcp NNTP used for usenet newsgroups 
220/tcp IMAP3 
443/tcp HTTPS used for securely transferring web pages 


********


thrift学习 是什么？为什么用？有什么好处？RMI？


mybatis原理学习


tomcat、nginx等服务器部署


mysql数据库知识 优化？分库？分表？


缓存Memcached原理  消息队列机制了解






